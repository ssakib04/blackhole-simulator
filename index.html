<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Premium Black Hole Simulator — Single File</title>
<style>
  :root{
    --bg:#060607;
    --panel:#0f1113;
    --muted:#9aa0a6;
    --accent:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
    --glass-2: rgba(255,255,255,0.02);
    --card-radius:16px;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#040405 0%, #0b0b0c 100%);font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:#e6eef3}
  .app{display:grid;grid-template-columns:360px 1fr;gap:18px;height:100vh;padding:18px;box-sizing:border-box}
  @media (max-width:900px){.app{grid-template-columns:1fr;grid-template-rows:auto 1fr;padding:12px}}
  .panel{
    background:linear-gradient(180deg,var(--panel),#0a0b0d);
    border-radius:var(--card-radius);
    padding:18px;box-shadow:0 6px 30px rgba(0,0,0,0.7);backdrop-filter: blur(6px);
    display:flex;flex-direction:column;gap:12px;min-height:0;
  }
  .title{display:flex;align-items:center;gap:12px}
  .logo{
    width:48px;height:48px;border-radius:10px;background:radial-gradient(circle at 30% 30%, #111 0%, #000 40%, #0b0b0c 60%);display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03)
  }
  h1{font-size:18px;margin:0}
  .muted{color:var(--muted);font-size:13px}
  .row{display:flex;gap:10px;align-items:center}
  label{font-size:13px;color:#cfd8dd}
  .control{background:var(--glass);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02)}
  input[type="range"]{width:100%}
  .flex{display:flex;gap:8px}
  .btn{background:linear-gradient(180deg,#111315,#0c0d0e);border-radius:12px;padding:8px 12px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;color:#e6eef3}
  .btn.primary{background:linear-gradient(180deg,#ff6b6b,#e94b4b);color:#09080a;border-radius:10px;font-weight:600}
  .small{font-size:12px;color:var(--muted)}
  .canvas-wrap{border-radius:16px;overflow:hidden;position:relative;box-shadow:inset 0 0 120px rgba(0,0,0,0.6)}
  canvas{display:block;width:100%;height:100%}
  .hud{
    position:absolute;left:12px;top:12px;background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.015));
    padding:8px;border-radius:10px;color:#dfe8ea;font-size:13px;border:1px solid rgba(255,255,255,0.03)
  }
  .grid-controls{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .stat{font-size:12px;color:var(--muted)}
  footer{margin-top:auto;font-size:12px;color:var(--muted);text-align:center}
  .input-num{display:flex;gap:8px;align-items:center}
  .input-num input[type=number]{width:110px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;}
  .toggle{display:inline-flex;align-items:center;gap:8px}
  .chip{padding:6px 8px;background:var(--glass-2);border-radius:999px;border:1px solid rgba(255,255,255,0.02);font-size:13px}
  .legend{display:flex;gap:8px;align-items:center}
  .dot{width:10px;height:10px;border-radius:50%}
  .controls-scroll{overflow:auto;padding-right:6px}
  ::-webkit-scrollbar{width:8px;height:8px}
  ::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.03);border-radius:999px}
  .preset-row{display:flex;gap:8px;flex-wrap:wrap}
  .preset-row .btn{padding:6px 8px;font-size:13px}
</style>
</head>
<body>
<div class="app">
  <aside class="panel">
    <div class="title">
      <div class="logo"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="9" fill="#090909" /><path d="M7 12a5 5 0 0 1 10 0" stroke="#ff6b6b" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg></div>
      <div>
        <h1>Black Hole Studio</h1>
        <div class="muted">Interactive black hole simulation — approximate GR visuals</div>
      </div>
    </div>

    <div class="controls-scroll" style="flex:1;min-height:0">
      <!-- BH Controls -->
      <div class="control">
        <div class="row" style="justify-content:space-between">
          <label>Black Hole</label>
          <div class="chip" id="bhRs">Rs: — km</div>
        </div>
        <div style="margin-top:8px">
          <label>Mass (solar masses)</label>
          <div class="input-num" style="margin-top:6px">
            <input id="massNum" type="number" min="1" max="200000000" step="1" value="10">
            <input id="massRange" type="range" min="1" max="100000" step="1" value="10">
          </div>
        </div>

        <div style="margin-top:12px">
          <label>Visual size multiplier</label>
          <input id="visualSize" type="range" min="0.2" max="8" step="0.05" value="1.0">
        </div>

        <div style="margin-top:12px" class="row">
          <label>Spin (a)</label>
          <input id="spin" type="range" min="0" max="0.99" step="0.01" value="0.6" style="flex:1">
        </div>
        <div style="margin-top:8px" class="row">
          <button class="btn" id="toggleSpin">Pause Spin</button>
          <button class="btn" id="resetBH">Reset BH</button>
        </div>
      </div>

      <!-- Stars Controls -->
      <div class="control" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <label>Stars & Bodies</label>
          <div class="small" id="starCountLabel">0 particles</div>
        </div>

        <div style="margin-top:8px">
          <label>Number of stars</label>
          <input id="numStars" type="range" min="0" max="200" step="1" value="20">
        </div>

        <div style="margin-top:10px" class="grid-controls">
          <div>
            <label>Star mass (relative: 0.1–10 M☉)</label>
            <input id="starMass" type="range" min="0.1" max="20" step="0.1" value="1">
          </div>
          <div>
            <label>Star radius (visual px)</label>
            <input id="starRadius" type="range" min="1" max="8" step="0.5" value="2.5">
          </div>
        </div>

        <div style="margin-top:10px" class="row">
          <label class="toggle"><input id="mutualGravity" type="checkbox" checked> Mutual star gravity</label>
          <label class="toggle"><input id="showTrails" type="checkbox" checked> Trails</label>
        </div>

        <div style="margin-top:10px" class="row">
          <button class="btn primary" id="applyStars">Apply & Spawn</button>
          <button class="btn" id="clearStars">Clear</button>
        </div>
      </div>

      <!-- Simulation Controls -->
      <div class="control" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <label>Simulation</label>
          <div class="small" id="simSpeedLabel">speed x1</div>
        </div>

        <div style="margin-top:8px">
          <label>Time acceleration</label>
          <input id="timeScale" type="range" min="0.02" max="5" step="0.02" value="1">
        </div>

        <div style="margin-top:8px">
          <label>Integrator</label>
          <div class="row">
            <select id="integrator" style="flex:1;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:inherit">
              <option value="leapfrog">Leapfrog (stable)</option>
              <option value="rk4">RK4 (accurate)</option>
            </select>
            <button class="btn" id="pauseBtn">Pause</button>
          </div>
        </div>

        <div style="margin-top:10px" class="row">
          <button class="btn" id="presetCalm">Preset: Calm</button>
          <button class="btn" id="presetChaotic">Preset: Chaotic</button>
        </div>
      </div>

      <!-- Info -->
      <div class="control" style="margin-top:12px">
        <label>Notes</label>
        <div class="small" style="margin-top:8px;line-height:1.4">
          - Uses Paczyński–Wiita pseudo-potential to approximate strong gravity. <br>
          - Frame-dragging is approximated for visual orbital precession. <br>
          - Toggle mutual gravity for N-body interactions (costly if many stars). <br>
          - Click canvas to add a single star at pointer; shift+click to remove nearest.
        </div>
      </div>
    </div>

    <footer>Made with ❤️ — physics approximations, not exact GR</footer>
  </aside>

  <main class="panel canvas-wrap">
    <div style="position:relative;flex:1;min-height:320px">
      <canvas id="scene"></canvas>
      <div class="hud" id="hud">
        <div style="font-weight:600">BH Mass: <span id="hudMass">10 M☉</span></div>
        <div class="row" style="margin-top:6px">
          <div class="stat">Particles: <span id="hudCount">0</span></div>
          <div style="width:8px"></div>
          <div class="stat">FPS: <span id="hudFPS">0</span></div>
          <div style="width:8px"></div>
          <div class="stat">t: <span id="hudTime">0.0</span>s</div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
/*
Black Hole Studio — single file
Author: ChatGPT (crafted for Sadman)
Notes: This is an interactive, responsive simulation using physics approximations:
- Paczynski–Wiita pseudo-potential to mimic inner orbit behavior near a Schwarzschild BH.
- Lense–Thirring-like tangential perturbation for spin-induced frame dragging.
- Leapfrog integrator (symplectic) for stability; RK4 available.
- Simple screen-space lensing approximation for visual photon bending.
Units: masses given in solar masses; scaling maps physical radii to pixels.
*/

/* ---------- Constants & helpers ---------- */
const AU = 1.495978707e11; // m (not used heavily)
const G_SI = 6.67430e-11;
const c_SI = 299792458;
const M_SUN = 1.98847e30;

// Utility
function clamp(x,a,b){return Math.max(a,Math.min(b,x))}
function len(x,y){return Math.hypot(x,y)}
function vecAdd(a,b){return {x:a.x+b.x,y:a.y+b.y}}
function vecScale(a,s){return {x:a.x*s,y:a.y*s}}
function vecSub(a,b){return {x:a.x-b.x,y:a.y-b.y}}
function copy(v){return {x:v.x,y:v.y}}
function nowMs(){return performance.now()}

/* ---------- Canvas & UI ---------- */
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha: false });

function resizeCanvas(){
  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth;
  canvas.height = parent.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Simulation state ---------- */
let state = {
  bh: {
    mass_solar: 10, // solar masses
    visualSize: 1.0, // multiplier for rendering
    spin: 0.6, // 0..0.99
    spinPaused: false,
    angVel: 0.0 // visual spin angle
  },
  stars: [], // objects: {pos:{x,y}, vel:{x,y}, mass_solar, radius_px, color, trail:[]}
  settings: {
    timeScale: 1.0,
    mutualGravity: true,
    trails: true,
    integrator: "leapfrog",
  },
  sim: {
    running: true,
    t: 0,
    fps: 0
  }
};

/* ---------- DOM elements ---------- */
const massNum = document.getElementById('massNum');
const massRange = document.getElementById('massRange');
const visualSize = document.getElementById('visualSize');
const spinRange = document.getElementById('spin');
const toggleSpinBtn = document.getElementById('toggleSpin');
const resetBHBtn = document.getElementById('resetBH');
const numStarsRange = document.getElementById('numStars');
const starMassRange = document.getElementById('starMass');
const starRadiusRange = document.getElementById('starRadius');
const mutualGravityCheckbox = document.getElementById('mutualGravity');
const applyStarsBtn = document.getElementById('applyStars');
const clearStarsBtn = document.getElementById('clearStars');
const timeScaleRange = document.getElementById('timeScale');
const integratorSelect = document.getElementById('integrator');
const pauseBtn = document.getElementById('pauseBtn');
const presetCalm = document.getElementById('presetCalm');
const presetChaotic = document.getElementById('presetChaotic');
const starCountLabel = document.getElementById('starCountLabel');
const hudMass = document.getElementById('hudMass');
const hudCount = document.getElementById('hudCount');
const hudFPS = document.getElementById('hudFPS');
const hudTime = document.getElementById('hudTime');
const bhRsChip = document.getElementById('bhRs');
const simSpeedLabel = document.getElementById('simSpeedLabel');
const massLabel = document.getElementById('hudMass');

/* ---------- Wire up UI ---------- */
massNum.addEventListener('input', e=>{
  let v=Number(e.target.value); massRange.value = v; state.bh.mass_solar=v; updateBHUI();
});
massRange.addEventListener('input', e=>{
  let v=Number(e.target.value); massNum.value=v; state.bh.mass_solar=v; updateBHUI();
});
visualSize.addEventListener('input', e=>{ state.bh.visualSize=Number(e.target.value); });
spinRange.addEventListener('input', e=>{ state.bh.spin=Number(e.target.value); });
toggleSpinBtn.addEventListener('click', ()=>{
  state.bh.spinPaused = !state.bh.spinPaused;
  toggleSpinBtn.textContent = state.bh.spinPaused ? 'Resume Spin' : 'Pause Spin';
});
resetBHBtn.addEventListener('click', ()=>{
  state.bh.angVel=0; state.bh.spin=0.6; spinRange.value=0.6;
  state.bh.visualSize=1; visualSize.value=1;
});
numStarsRange.addEventListener('input', ()=>{ document.getElementById('starCountLabel').textContent = numStarsRange.value + ' spawn count';});
applyStarsBtn.addEventListener('click', spawnStarsFromUI);
clearStarsBtn.addEventListener('click', ()=>{ state.stars=[]; });
timeScaleRange.addEventListener('input', ()=>{ state.settings.timeScale = Number(timeScaleRange.value); simSpeedLabel.textContent = 'speed x' + state.settings.timeScale.toFixed(2);});
integratorSelect.addEventListener('change', ()=>{ state.settings.integrator = integratorSelect.value; });
pauseBtn.addEventListener('click', ()=>{ state.sim.running = !state.sim.running; pauseBtn.textContent = state.sim.running ? 'Pause' : 'Resume'; });
presetCalm.addEventListener('click', ()=>{ setPreset('calm');});
presetChaotic.addEventListener('click', ()=>{ setPreset('chaotic');});
mutualGravityCheckbox.addEventListener('change', ()=>{ state.settings.mutualGravity = mutualGravityCheckbox.checked; });
document.getElementById('showTrails').addEventListener('change', ()=>{ state.settings.trails = document.getElementById('showTrails').checked; });

function updateBHUI(){
  const M = state.bh.mass_solar;
  hudMass.textContent = M.toLocaleString() + ' M☉';
  const Rs = schwarzschildRadiusMeters(M);
  const Rs_km = (Rs/1000).toFixed(3);
  bhRsChip.textContent = `Rs: ${Rs_km} km`;
}
updateBHUI();

/* ---------- Physics core ---------- */

// Compute Schwarzschild radius in meters
function schwarzschildRadiusMeters(mass_solar){
  const M = mass_solar * M_SUN;
  return 2 * G_SI * M / (c_SI*c_SI);
}

// Map physical radius (meters) -> pixels, via scale that depends on canvas size & BH mass
function physicalToPixels(r_m){
  // choose a scale so that a few tens of Rs fit comfortably
  const Rs = schwarzschildRadiusMeters(state.bh.mass_solar);
  // reference pixels per Rs
  const base = Math.min(canvas.width, canvas.height) / 6; // want ~6 Rs across smaller dimension
  const pxPerMeter = (base / Rs) * state.bh.visualSize;
  return r_m * pxPerMeter;
}
function pixelsToPhysical(px){
  const Rs = schwarzschildRadiusMeters(state.bh.mass_solar);
  const base = Math.min(canvas.width, canvas.height) / 6;
  const pxPerMeter = (base / Rs) * state.bh.visualSize;
  return px / pxPerMeter;
}

// Paczyński–Wiita potential (mimics innermost stable circular orbit for Schwarzschild)
function pwPotentialPhi(r_m, mass_solar){
  // Phi = -GM / (r - Rs)
  const M = mass_solar * M_SUN;
  const Rs = schwarzschildRadiusMeters(mass_solar);
  return - G_SI * M / Math.max( (r_m - Rs), 1e-9 );
}

// Force magnitude from Paczynski–Wiita
function pwForceMagnitude(r_m, mass_solar){
  const M = mass_solar * M_SUN;
  const Rs = schwarzschildRadiusMeters(mass_solar);
  // F = -dPhi/dr = -GM / (r - Rs)^2
  return G_SI * M / Math.pow(Math.max(r_m - Rs, 1e-9), 2);
}

// Small-angle deflection approximation for lensing: alpha ≈ 4GM/(c^2 b) (radians)
// We'll use softened and scaled form for visuals
function deflectionAngle(b_m, mass_solar){
  const M = mass_solar * M_SUN;
  const alpha = 4 * G_SI * M / (c_SI*c_SI * Math.max(b_m, 1e-6));
  // cap and soften for visuals:
  return Math.atan(alpha) * 1.6;
}

/* ---------- Particle integrators ---------- */

function computeAccelerationOn(star, stars, includeMutual){
  // return acceleration {x,y} in physical meters/sec^2
  // acceleration due to BH (centered at origin)
  const x = star.posPhys.x, y = star.posPhys.y;
  const r = Math.hypot(x, y);
  const mag = pwForceMagnitude(r, state.bh.mass_solar);
  // radial unit vector
  const ax_bh = -mag * (x/r || 0);
  const ay_bh = -mag * (y/r || 0);

  // frame-dragging approx: introduce small azimuthal acceleration proportional to spin and 1/r^3
  // This is NOT exact Lense-Thirring, but produces orbital precession visually.
  const s = state.bh.spin * (state.bh.spinPaused ? 0 : 1);
  let ax_spin = 0, ay_spin = 0;
  if (s > 0){
    const factor = s * (G_SI * (state.bh.mass_solar*M_SUN)) / Math.pow(Math.max(r,1e-9), 3);
    // perpendicular to radial vector to add tangential push (clockwise or counter)
    const tx = -y/r, ty = x/r; // 90deg rotated unit vector
    ax_spin = factor * tx;
    ay_spin = factor * ty;
  }

  let ax = ax_bh + ax_spin;
  let ay = ay_bh + ay_spin;

  // mutual gravity between stars (optional)
  if (includeMutual){
    for (let other of stars){
      if (other === star) continue;
      const dx = other.posPhys.x - x;
      const dy = other.posPhys.y - y;
      const dist = Math.hypot(dx,dy);
      if (dist < 1e-6) continue;
      const mOther = other.mass_solar * M_SUN;
      const aMag = G_SI * mOther / (dist*dist);
      ax += aMag * (dx/dist);
      ay += aMag * (dy/dist);
    }
  }
  return {x: ax, y: ay};
}

// Leapfrog integrator step (positions in meters, velocities in m/s)
function leapfrogStep(dt, stars){
  // half-kick
  const half = dt * 0.5;
  const includeMutual = state.settings.mutualGravity;
  // compute accelerations at current positions
  const accs = stars.map(s => computeAccelerationOn(s, stars, includeMutual));
  for (let i=0;i<stars.length;i++){
    const s = stars[i];
    s.vel.x += accs[i].x * half;
    s.vel.y += accs[i].y * half;
    // drift
    s.posPhys.x += s.vel.x * dt;
    s.posPhys.y += s.vel.y * dt;
  }
  // recompute accelerations and finish kick
  const accs2 = stars.map(s => computeAccelerationOn(s, stars, includeMutual));
  for (let i=0;i<stars.length;i++){
    const s = stars[i];
    s.vel.x += accs2[i].x * half;
    s.vel.y += accs2[i].y * half;
  }
}

// RK4 integrator for comparison (less stable for long sims but more accurate per step)
function rk4Step(dt, stars){
  const includeMutual = state.settings.mutualGravity;
  function accForPositions(posArray, idx){
    // posArray is array of {x,y} for all stars
    // compute acceleration on star idx due to BH + others using these posArray positions
    const x = posArray[idx].x, y = posArray[idx].y;
    const r = Math.hypot(x,y);
    const mag = pwForceMagnitude(r, state.bh.mass_solar);
    const ax_bh = -mag * (x/r || 0);
    const ay_bh = -mag * (y/r || 0);
    // spin term
    const s = state.bh.spin * (state.bh.spinPaused ? 0 : 1);
    let ax_spin = 0, ay_spin = 0;
    if (s > 0){
      const factor = s * (G_SI * (state.bh.mass_solar*M_SUN)) / Math.pow(Math.max(r,1e-9), 3);
      const tx = -y/r, ty = x/r;
      ax_spin = factor * tx;
      ay_spin = factor * ty;
    }
    let ax = ax_bh + ax_spin, ay = ay_bh + ay_spin;
    if (includeMutual){
      for (let j=0;j<posArray.length;j++){
        if (j===idx) continue;
        const dx = posArray[j].x - x;
        const dy = posArray[j].y - y;
        const dist = Math.hypot(dx,dy);
        if (dist < 1e-8) continue;
        const mOther = stars[j].mass_solar * M_SUN;
        const aMag = G_SI * mOther / (dist*dist);
        ax += aMag * (dx/dist);
        ay += aMag * (dy/dist);
      }
    }
    return {x:ax, y:ay};
  }

  const n = stars.length;
  if (n === 0) return;
  // Prepare arrays
  const pos0 = stars.map(s => ({x:s.posPhys.x, y:s.posPhys.y}));
  const vel0 = stars.map(s => ({x:s.vel.x, y:s.vel.y}));

  // k1
  const a1 = pos0.map((p,i)=>accForPositions(pos0,i));
  // k2 positions & velocities
  const pos_k2 = pos0.map((p,i)=>({x:p.x + vel0[i].x*dt*0.5, y:p.y + vel0[i].y*dt*0.5}));
  const vel_k2 = vel0.map((v,i)=>({x:v.x + a1[i].x*dt*0.5, y:v.y + a1[i].y*dt*0.5}));
  const a2 = pos_k2.map((p,i)=>accForPositions(pos_k2,i));
  // k3
  const pos_k3 = pos0.map((p,i)=>({x:p.x + vel_k2[i].x*dt*0.5, y:p.y + vel_k2[i].y*dt*0.5}));
  const vel_k3 = vel0.map((v,i)=>({x:v.x + a2[i].x*dt*0.5, y:v.y + a2[i].y*dt*0.5}));
  const a3 = pos_k3.map((p,i)=>accForPositions(pos_k3,i));
  // k4
  const pos_k4 = pos0.map((p,i)=>({x:p.x + vel_k3[i].x*dt, y:p.y + vel_k3[i].y*dt}));
  const vel_k4 = vel0.map((v,i)=>({x:v.x + a3[i].x*dt, y:v.y + a3[i].y*dt}));
  const a4 = pos_k4.map((p,i)=>accForPositions(pos_k4,i));

  // combine
  for (let i=0;i<n;i++){
    const s = stars[i];
    s.posPhys.x += dt*(vel0[i].x + 2*vel_k2[i].x + 2*vel_k3[i].x + vel_k4[i].x)/6;
    s.posPhys.y += dt*(vel0[i].y + 2*vel_k2[i].y + 2*vel_k3[i].y + vel_k4[i].y)/6;
    s.vel.x += dt*(a1[i].x + 2*a2[i].x + 2*a3[i].x + a4[i].x)/6;
    s.vel.y += dt*(a1[i].y + 2*a2[i].y + 2*a3[i].y + a4[i].y)/6;
  }
}

/* ---------- Init & spawn functions ---------- */

function spawnStarsFromUI(){
  const n = Number(numStarsRange.value);
  const m = Number(starMassRange.value);
  const r_px = Number(starRadiusRange.value);
  spawnStars(n, m, r_px);
}

function spawnStars(count = 20, mass_solar=1, radius_px=2.5){
  // Place stars in circular-ish orbits around center, randomized radii
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2;

  const Rs_m = schwarzschildRadiusMeters(state.bh.mass_solar);
  const innerR_m = Rs_m * 2.6; // a bit outside horizon
  const outerR_m = pixelsToPhysical(Math.min(w,h) * 0.45); // far out

  for (let i=0;i<count;i++){
    // sample radius logarithmically
    const t = i / Math.max(1,count-1);
    // randomized distribution with bias outward
    const r_m = innerR_m * Math.pow( (outerR_m/innerR_m), Math.random() );
    const theta = Math.random() * Math.PI * 2;
    // desired near-circular speed for Paczyński–Wiita potential:
    // v_circ^2 = r * dPhi/dr  (approx) => v^2 = GM r / (r - Rs)^2 * (1/r) ??? We'll compute from centripetal requirement using pwForceMagnitude:
    // centripetal v = sqrt(r * F(r) ) where F(r) = GM/(r-Rs)^2
    const Fmag = pwForceMagnitude(r_m, state.bh.mass_solar);
    const v_circ = Math.sqrt( r_m * Fmag );

    // small eccentricity
    const ecc = (Math.random()*0.18 - 0.09);
    const vx = Math.cos(theta + Math.PI/2) * v_circ * (1+ecc);
    const vy = Math.sin(theta + Math.PI/2) * v_circ * (1+ecc);

    const posPhys = {x: r_m * Math.cos(theta), y: r_m * Math.sin(theta)};
    // convert to screen
    const posPx = physToScreen(posPhys);

    const star = {
      id: Math.random().toString(36).slice(2,9),
      mass_solar: mass_solar * (0.5 + Math.random()*1.5), // little variance
      radius_px: radius_px * (0.7 + Math.random()*0.8),
      color: randomStarColor(),
      posPhys: posPhys,
      vel: {x: vx, y: vy},
      trail: []
    };
    // small random velocity jitter
    star.vel.x *= (0.95 + Math.random()*0.1);
    star.vel.y *= (0.95 + Math.random()*0.1);

    state.stars.push(star);
  }
}

function clearStars(){ state.stars = []; }

function randomStarColor(){
  // luminous pastel-ish
  const palette = ['#ffd9a6','#fff7b2','#ffd7e0','#d9f1ff','#e0ffd6'];
  return palette[Math.floor(Math.random()*palette.length)];
}

/* ---------- Screen & conversion helpers ---------- */
function physToScreen(posPhys){
  // center in canvas center
  const cx = canvas.width/2, cy = canvas.height/2;
  return {
    x: cx + physicalToPixels(posPhys.x),
    y: cy + physicalToPixels(posPhys.y)
  };
}
function screenToPhys(screen){
  const cx = canvas.width/2, cy = canvas.height/2;
  return {
    x: pixelsToPhysical(screen.x - cx),
    y: pixelsToPhysical(screen.y - cy)
  };
}

/* ---------- Input interactions ---------- */
canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  if (ev.shiftKey){
    // remove nearest star
    let nearest = null, nd = Infinity;
    for (let s of state.stars){
      const scr = physToScreen(s.posPhys);
      const d = Math.hypot(scr.x - x, scr.y - y);
      if (d < nd){ nd = d; nearest = s; }
    }
    if (nearest && nd < 30) state.stars = state.stars.filter(s => s !== nearest);
  } else {
    // spawn a single star with initial near-circular velocity at clicked radius
    const phys = screenToPhys({x,y});
    const r = Math.hypot(phys.x, phys.y);
    if (r < schwarzschildRadiusMeters(state.bh.mass_solar)*1.01) return; // avoid placing inside horizon
    const theta = Math.atan2(phys.y, phys.x);
    const Fmag = pwForceMagnitude(r, state.bh.mass_solar);
    const v_circ = Math.sqrt(r * Fmag);
    const vx = Math.cos(theta + Math.PI/2) * v_circ;
    const vy = Math.sin(theta + Math.PI/2) * v_circ;
    const star = {
      id: Math.random().toString(36).slice(2,9),
      mass_solar: Number(starMassRange.value),
      radius_px: Number(starRadiusRange.value),
      color: randomStarColor(),
      posPhys: {x:phys.x, y:phys.y},
      vel: {x: vx, y: vy},
      trail: []
    };
    state.stars.push(star);
  }
});

/* ---------- Rendering ---------- */

function drawBackground(){
  // deep space gradient with faint speckles
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, '#040405');
  g.addColorStop(1, '#0b0b0c');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // field stars (static faint)
  const seed = 42;
  // draw several faint stars procedurally, deterministic
  for (let i=0;i<120;i++){
    const x = ( (i*9301 + 49297) % 1000)/1000 * canvas.width;
    const y = ( (i*23333 + 12345) % 1000)/1000 * canvas.height;
    ctx.globalAlpha = 0.75 * ( (i%7===0) ? 0.8 : 0.25 );
    ctx.fillStyle = '#ffffff';
    const size = (i%11===0) ? 1.6 : 0.6;
    ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// Draw black hole: event horizon, photon ring, accretion glow with spin
function drawBlackHole(){
  const cx = canvas.width/2, cy = canvas.height/2;
  const Rs_m = schwarzschildRadiusMeters(state.bh.mass_solar);
  const horizonR_px = physicalToPixels(Rs_m);
  // Photon sphere approx radius: 1.5 * Rs for Schwarzschild - visually scaled by spin
  const photonR_px = physicalToPixels(Rs_m * 1.5) * (1 + 0.25 * state.bh.spin);

  // Accretion glow: rotating radial gradient
  const grd = ctx.createRadialGradient(cx,cy, horizonR_px*0.2, cx,cy, photonR_px*3);
  const spinHue = Math.floor(330 * state.bh.spin);
  grd.addColorStop(0.0, `rgba(255,${200 - spinHue/2},80,0.95)`);
  grd.addColorStop(0.12, `rgba(255,${210 - spinHue/1.5},120,0.65)`);
  grd.addColorStop(0.22, 'rgba(120,60,180,0.18)');
  grd.addColorStop(0.5, 'rgba(6,6,8,0.02)');
  ctx.fillStyle = grd;
  ctx.beginPath(); ctx.arc(cx,cy, photonR_px*2.4, 0, Math.PI*2); ctx.fill();

  // photon ring (bright)
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let k=0;k<8;k++){
    ctx.beginPath();
    ctx.lineWidth = 2 + k*0.3;
    ctx.strokeStyle = `rgba(255,200,140,${0.12 - k*0.012})`;
    ctx.arc(cx,cy, photonR_px*(1 + k*0.003), 0, Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();

  // Event horizon (dark)
  ctx.beginPath();
  ctx.fillStyle = '#000000';
  ctx.arc(cx,cy, horizonR_px, 0, Math.PI*2);
  ctx.fill();

  // subtle rim highlight for depth
  ctx.beginPath();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.arc(cx,cy, horizonR_px+1.2, 0, Math.PI*2);
  ctx.stroke();
}

// Map screen coordinate for a background star with deflection from BH
function deflectScreenPoint(x,y){
  // compute separation from BH center in screen px
  const cx = canvas.width/2, cy = canvas.height/2;
  const dx = x - cx, dy = y - cy;
  const b_px = Math.hypot(dx,dy);
  if (b_px < 2) return {x,y}; // skip
  // map px -> physical impact parameter
  const b_m = pixelsToPhysical(b_px);
  const alpha = deflectionAngle(b_m, state.bh.mass_solar);
  // deflection in radians, approximate as rotating the vector by alpha toward center
  // For visuals, scale down alpha
  const maxAlpha = 0.35; // rad
  const a = clamp(alpha, 0, maxAlpha);
  // rotate vector (dx,dy) by -a (toward center)
  const angle = Math.atan2(dy,dx);
  const newAngle = angle - a;
  const nx = cx + b_px * Math.cos(newAngle);
  const ny = cy + b_px * Math.sin(newAngle);
  return {x:nx, y:ny};
}

// draw stars and trails
function drawStars(){
  const cx = canvas.width/2, cy = canvas.height/2;
  for (let s of state.stars){
    const scr = physToScreen(s.posPhys);
    // Skip if offscreen
    if (scr.x < -50 || scr.x > canvas.width + 50 || scr.y < -50 || scr.y > canvas.height+50) continue;

    // trail
    if (state.settings.trails && s.trail && s.trail.length>1){
      ctx.beginPath();
      ctx.moveTo(s.trail[0].x, s.trail[0].y);
      for (let p of s.trail) ctx.lineTo(p.x,p.y);
      ctx.strokeStyle = s.color;
      ctx.globalAlpha = 0.18;
      ctx.lineWidth = Math.max(1, s.radius_px*0.6);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // lensing: the star appears displaced / smeared near BH: sample a deflected position for rendering
    const def = deflectScreenPoint(scr.x, scr.y);
    // drawing star glow
    ctx.beginPath();
    // outer glow
    ctx.fillStyle = s.color;
    ctx.globalAlpha = 0.08;
    ctx.arc(def.x, def.y, s.radius_px*4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    // core
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(def.x, def.y, Math.max(1.0, s.radius_px*0.5), 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = s.color;
    ctx.globalAlpha = 0.95;
    ctx.arc(def.x, def.y, s.radius_px*0.9, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

/* ---------- Main loop ---------- */

let lastFrameTime = nowMs(), fpsTimer = 0, fpsCount = 0;
function stepFrame(){
  const tNow = nowMs();
  let dtMs = tNow - lastFrameTime;
  if (dtMs > 80) dtMs = 80; // clamp huge gaps
  lastFrameTime = tNow;

  const dtSec = dtMs / 1000 * state.settings.timeScale;
  // physics update
  if (state.sim.running){
    // scale substeps depending on dt and number of particles for stability
    const n = state.stars.length || 1;
    let substeps = 1;
    if (dtSec > 0.01) substeps = Math.ceil(dtSec / 0.01);
    // also smaller dt if many particles
    if (n > 60) substeps = Math.max(substeps, Math.ceil(n / 60));
    const stepDt = dtSec / substeps;
    for (let s=0;s<substeps;s++){
      if (state.settings.integrator === 'leapfrog'){
        leapfrogStep(stepDt, state.stars);
      } else {
        rk4Step(stepDt, state.stars);
      }
      // update trails & check capture
      for (let p of state.stars){
        // push screen pos to trail
        if (state.settings.trails){
          const scr = physToScreen(p.posPhys);
          p.trail.push({x:scr.x, y:scr.y});
          if (p.trail.length > 160) p.trail.shift();
        } else {
          p.trail = [];
        }
        // capture / swallowed if inside horizon*1.02
        const r_m = Math.hypot(p.posPhys.x, p.posPhys.y);
        const Rs = schwarzschildRadiusMeters(state.bh.mass_solar);
        if (r_m <= Rs*1.01){
          // remove particle
          state.stars = state.stars.filter(q=>q !== p);
          break;
        }
      }
    }

    // BH visual spin evolution (affects accretion glow orientation)
    if (!state.bh.spinPaused) state.bh.angVel += 0.01 * state.bh.spin * (dtMs/16);
    state.sim.t += dtSec;
  }

  // render
  render();

  // HUD update
  fpsTimer += dtMs;
  fpsCount++;
  if (fpsTimer >= 500){
    const fps = Math.round(fpsCount * (1000/fpsTimer));
    state.sim.fps = fps;
    hudFPS.textContent = fps;
    fpsTimer = 0;
    fpsCount = 0;
  }
  hudCount.textContent = state.stars.length;
  hudTime.textContent = state.sim.t.toFixed(2);

  requestAnimationFrame(stepFrame);
}

function render(){
  // draw background
  drawBackground();

  // apply a small parallax / swirl to background using BH spin for subtle premium feel
  // (We'll draw background stars first, then BH)
  // draw stars and trails
  drawStars();

  // draw central black hole
  drawBlackHole();

  // draw overlay HUD elements (nothing heavy)
  // small crosshair center
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  ctx.arc(canvas.width/2, canvas.height/2, 2, 0, Math.PI*2);
  ctx.stroke();
}

/* ---------- Presets ---------- */
function setPreset(p){
  if (p === 'calm'){
    massNum.value = 50; massRange.value = 50; state.bh.mass_solar = 50;
    visualSize.value = 1.0; state.bh.visualSize = 1.0;
    spinRange.value = 0.3; state.bh.spin = 0.3;
    numStarsRange.value = 18;
    starMassRange.value = 1.2;
    starRadiusRange.value = 2.8;
    timeScaleRange.value = 1.0; state.settings.timeScale = 1.0;
    document.getElementById('mutualGravity').checked = false; state.settings.mutualGravity=false;
    state.stars = [];
    spawnStars(18,1.2,2.8);
  } else {
    massNum.value = 15; massRange.value = 15; state.bh.mass_solar = 15;
    visualSize.value = 1.2; state.bh.visualSize = 1.2;
    spinRange.value = 0.8; state.bh.spin = 0.8;
    numStarsRange.value = 60;
    starMassRange.value = 1.8;
    starRadiusRange.value = 3.5;
    timeScaleRange.value = 1.6; state.settings.timeScale = 1.6;
    document.getElementById('mutualGravity').checked = true; state.settings.mutualGravity=true;
    state.stars = [];
    spawnStars(60, 1.8, 3.5);
  }
  updateBHUI();
}

/* ---------- Init scene ---------- */
setPreset('calm');
requestAnimationFrame(stepFrame);

/* ---------- Misc updates & UI feedback ---------- */
function updateHUDMass(){ hudMass.textContent = Number(state.bh.mass_solar).toLocaleString() + ' M☉'; }
setInterval(()=>{ updateBHUI(); hudCount.textContent = state.stars.length; }, 600);

/* ---------- Small polish: keyboard shortcuts ---------- */
window.addEventListener('keydown', (e)=>{
  if (e.key === ' ') { state.sim.running = !state.sim.running; pauseBtn.textContent = state.sim.running ? 'Pause' : 'Resume'; e.preventDefault(); }
  if (e.key === 'r') { state.stars = []; }
});

/* ---------- final notes in console ---------- */
console.log("Black Hole Studio loaded. Tips:\n- Click to spawn a star at pointer. Shift+click to remove nearest.\n- Use presets for quick setups. Increase/decrease timeScale for faster/slow simulation.\n\nPhysics: Paczynski-Wiita pseudo-potential and a simple spin perturbation are used for interactive, qualitative strong-field behaviour.");
</script>
</body>
</html>
